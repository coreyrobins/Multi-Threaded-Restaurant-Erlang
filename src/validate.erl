-module(validate).
-export([check/1]).

% validation: given a list of events generated by a simulation, checks
% that the events are well-formed.  With throw an exception if
% there is a problem; otherwise returns ok.
check([{simulation_starting,
		  [NEaters,NCooks,NTables,Capacity]}|Events]) ->
    {simulation_ending,ok} = last(Events),
    true = (NEaters >= count_eaters(Events)),
    true = (NCooks >= count_cooks(Events)),
    true = (NTables >= restaurant_capacity(Events)),
    true = (Capacity >= machine_capacity(Events)),
    complete_before_received(Events),
    receive_before_leaving(Events),
    only_one_order(Events),
    order_before_cook(Events).
    
count_eaters(Events) ->
    S2 = lists:foldl(fun(X, S) ->
			     case X of
				 {eater_starting,Eater} ->
				     sets:add_element(Eater,S);
				 {eater_entered,Eater} -> 
				     sets:add_element(Eater,S);
				 {eater_ordered,[Eater,_,_]} -> 
				     sets:add_element(Eater,S);
				 {eater_received_order,[Eater,_]} -> 
				     sets:add_element(Eater,S);
				 {eater_leaving,Eater} -> 
				     sets:add_element(Eater,S);
				 _ -> S
			     end
		     end, sets:new(), Events),
    sets:size(S2).
    
count_cooks(Events) ->
    S2 = lists:foldl(fun(X, S) ->
			     case X of
				 {cook_starting,Cook} -> 
				     sets:add_element(Cook,S);
				 {cook_received_order,[Cook,_,_]} ->
				     sets:add_element(Cook,S);
				 {cook_started_food,[Cook,_,_]} ->
				     sets:add_element(Cook,S);
				 {cook_finished_food,[Cook,_,_]} ->
				     sets:add_element(Cook,S);
				 {cook_completed_order,[Cook,_]} ->
				     sets:add_element(Cook,S);
				 {cook_ending,Cook} ->
				     sets:add_element(Cook,S);
				 _ -> S
			     end
		     end, sets:new(), Events),
    sets:size(S2).

restaurant_capacity(Events) ->
    {_,MaxFilled} = lists:foldl(fun(X,{Curr,Max}) ->
					case X of
					    {eater_entered,_} -> 
						if (Curr+1) > Max ->
							{Curr+1,Curr+1};
						   true ->
							{Curr+1,Max}
						end;
					    {eater_leaving,_} ->
						{Curr-1,Max};
					    _ -> {Curr,Max}
					end
				end, {0,0}, Events),
    MaxFilled.

machine_capacity(Events) ->
    D = dict:from_list([{grill, {0,0}},
			 {frier, {0,0}},
			 {soda_fountain, {0,0}}]),
    D2 = lists:foldl(fun(X,Dict) ->
			    case X of
				{machine_cooking,[Machine,_]} ->
				    {ok, {Curr,Max}} = dict:find(Machine,Dict),
				    if (Curr+1) > Max ->
					    dict:store(Machine,{Curr+1,Curr+1},Dict);
				       true ->
					    dict:store(Machine,{Curr+1,Max},Dict)
				    end;
				{machine_done_food,[Machine,_]} ->
				    {ok, {Curr,Max}} = dict:find(Machine,Dict),
				    dict:store(Machine,{Curr-1,Max},Dict);
				_ -> Dict
			    end
		     end, D, Events),
    dict:fold(fun(_,{_,DMax},TMax) ->
		       if (DMax > TMax) ->
			       DMax;
			  true -> DMax
		       end
	       end, 0, D2).

complete_before_received(Events) ->
    lists:foldl(fun(X,Orders) ->
			case X of
			    {cook_completed_order,[_,Num]} -> 
				sets:add_element(Num,Orders);
			    {eater_received_order,[_,Num]} ->
				true = sets:is_element(Num,Orders),
				sets:del_element(Num,Orders);
			    _ -> Orders
			end
		end, sets:new(), Events),
    ok.

receive_before_leaving(Events) ->
    lists:foldl(fun(X,Eaters) ->
			case X of
			    {eater_received_order,[Eater,_]} ->
				sets:add_element(Eater,Eaters);
			    {eater_leaving,Eater} ->
				true = sets:is_element(Eater,Eaters),
				sets:del_element(Eater,Eaters);
			    _ -> Eaters
			end
		end, sets:new(), Events),
    ok.

only_one_order(Events) ->
    lists:foldl(fun(X,Eaters) ->
			case X of
			    {eater_ordered,[Eater,_,_]}	->
				false = sets:is_element(Eater,Eaters),
				sets:add_element(Eater,Eaters);
			    _ -> Eaters
			end
		end, sets:new(), Events),
    ok.

order_before_cook(Events) ->
    lists:foldl(fun(X,Orders) ->
			case X of
			    {eater_ordered,[_,Num,_]} ->
				sets:add_element(Num,Orders);
			    {cook_received_order,[_,Num,_]} ->
				true = sets:is_element(Num,Orders),
				Orders;
			    {cook_started_food,[_,Num,_]} ->
				true = sets:is_element(Num,Orders),
				Orders;
			    _ -> Orders
			end
		end, sets:new(), Events),
    ok.
    	    
last([X]) -> X;
last([_|T]) -> last(T).
